- v-html可以用来插入dom节点，但是不能直接接受用户的输入，会造成安全隐患
- vue中用来创建响应式变量的方法，ref(),reactive(),shallowRef,shallowReactive()
- v-bind
  - 如果绑定的是字符串类型，可以不使用
  - v-bind=对象，可以快速的将多个属性传递给子组件，或者将多个属性绑定在dom节点以及  
  子组件的根节点上。
- ref和reactive的区别
  - ref可以接受任何类型的值，本质是创建一个对象，然后把值绑定在对象的value属性上
  - reactive只能接受对象，数组，map,set
- ref和shallowRef区别（接受类型是引用类型的时候）
  - ref创建的是深层监听，开销较大
  - shallowRef，创建的是浅层监听开销比较小.let a = shallowRef(Obj)  
  只有a.value的值发生变化的时候，才会更新
- reactive的局限性
  - 当替换整个对象的时候，它监听不到变化
  - 只能接受有限的数据类型
  - 对于结构操作不够友好
- 绑定在组件上的class，会绑定在子组件的根节点上
- v-if和v-for同时绑定。
  - 首先不推荐这样使用。v-if的优先级比较高，它访问不到v-for中定义的变量。
  - 解决办法 1.使用计算属性，先对原始的数据进行过滤
  - 用template包裹需要循环的内容，给template添加v-for,然后在节点上添加v-if
- v-if和v-show区别
  - 如果是绑定在dom节点上，v-if会销毁掉dom节点，而v-show相当与display:none
  - 如果是绑定在组件上。v-if只有为true的时候，才会去创建组件实例。v-show会立马  
  创建组件实力。v-if在切换的时候，组件实例会创建和销毁。v-show不会。
  - 针对平凡切换的，我们首选v-show.需要触发生命周期的，我们用v-if.
- computed:需要是纯函数
- watch(监听对象，回调函数，配置)
  - watch监听对象的3中方式，响应式对象/ref,getter函数，数组
  - watch默认是深层监听
  - watch默认在监听对象发生改变后在执行。immediate:true转变成立即执行.  
  deep:true,深层监听，false，浅层监听
- watchEffect
  - 自动监听依赖，值监同步任务中的依赖
  - 立即执行
- watch和watchEffect执行时机，是在父组件更新之后，当前组件更新之前执行
  - flush:true,让回调在组件更新之后执行
  - 都会返回一个函数，调用该函数，可以停止侦听
  - 异步侦听器，需要自己手动销毁
- ref绑定在组件和绑定到dom
  - 绑定在组件，可以调用组件的方法
  - 绑定在dom，可以调用dom方法
- <component :is="componentName"/>,动态组件。在切换的时候，默认会被销毁  
  可以使用<keep-alive>组件让其保留
- 生命周期
  - beforeCreate: 组件实例没有创建，不能访问this。用来做一些初始化操作
  - created:组件实例已经创建，可以访问this，可有用来请求数据
  - beforeMount:dom节点尚未挂在，不可以访问dom
  - Mounted:dom节点已经挂在
  - beforeUnmount: 清理定时器，副作用
  - unmounted:组件已经卸载
  - 更新时
  - beforeUpdate: 数据已经更新，dom未更新
  - updated: dom已经更新
  - keep-alive包裹的组件
  - activated: 组件被激活
  - deactivated:从dom中溢出
- dev:开发环境启动项目
- build: 打包，生产
- preview: 以打包后的dist目录作为静态资源，本地启动一个服务器，在浏览器上可以访问
- lint: eslint校验，并修复eslint问题
- format: 格式化代码